name: Build and Push Docker Images

on:
  workflow_dispatch:
  # push:
  #   branches:
  #     - main  # or your default branch

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ROOT_DIRECTORY: /opt

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml

    - name: Log in to the Container registry
      uses: docker/login-action@v1
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Parse docker-compose file and build/push images
      run: |
        import yaml
        import os

        def parse_docker_compose():
            with open('docker-compose.yml', 'r') as file:
                return yaml.safe_load(file)

        def build_and_push_image(service, config):
            if 'build' not in config:
                return  # Skip services without build context

            context = config['build'].get('context', '.')
            dockerfile = config['build'].get('dockerfile', 'Dockerfile')
            
            if not os.path.isabs(dockerfile):
                dockerfile = os.path.join(context, dockerfile)
            
            print(f"Processing service: {service}")
            print(f"Context for {service}: {context}")
            print(f"Dockerfile for {service}: {dockerfile}")
            
            registry = os.environ['REGISTRY']
            image_name = os.environ['IMAGE_NAME']
            
            build_cmd = f"docker build -t {registry}/{image_name}/{service}:latest -f {dockerfile} {context}"
            push_cmd = f"docker push {registry}/{image_name}/{service}:latest"
            
            print(f"Building image for {service}...")
            os.system(build_cmd)
            
            print(f"Pushing image for {service}...")
            os.system(push_cmd)
            
            print(f"Completed processing for {service}")
            print(f"Image pushed to: {registry}/{image_name}/{service}:latest")
            print("-----------------------------------")

        docker_compose = parse_docker_compose()
        services_to_push = [service for service, config in docker_compose['services'].items() if 'build' in config]

        for service in services_to_push:
            build_and_push_image(service, docker_compose['services'][service])

        print("\nSummary of pushed images:")
        for service in services_to_push:
            print(f"ghcr.io/{os.environ['IMAGE_NAME']}/{service}:latest")
      shell: python

    - name: Create .env file for host
      run: |
        echo "${{ secrets.ENV_FILE }}" > .env

    - name: Copy .env and docker-compose-deploy files to remote server
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        source: ".env,docker-compose-deploy.yml"
        target: "/tmp"

    - name: Create dozzle/data directory and copy user.yml
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          sudo mkdir -p ${{ env.ROOT_DIRECTORY }}/dozzle/data
          cat <<EOL > ${{ env.ROOT_DIRECTORY }}/dozzle/data/users.yml
          ${{ secrets.DOZZLE_USER_YAML }}
          EOL
          sudo chown -R ${{ secrets.USER }}:${{ secrets.USER }} ${{ env.ROOT_DIRECTORY }}/dozzle
          sudo chmod 600 ${{ env.ROOT_DIRECTORY }}/dozzle/data/users.yml

    - name: Move files to ROOT_DIRECTORY and set permissions
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          sudo mv /tmp/.env /tmp/docker-compose-deploy.yml ${{ env.ROOT_DIRECTORY }}/
          sudo mv ${{ env.ROOT_DIRECTORY }}/docker-compose-deploy.yml ${{ env.ROOT_DIRECTORY }}/docker-compose.yml
          sudo chown ${{ secrets.USER }}:${{ secrets.USER }} ${{ env.ROOT_DIRECTORY }}/.env ${{ env.ROOT_DIRECTORY }}/docker-compose.yml
          sudo chmod 600 ${{ env.ROOT_DIRECTORY }}/.env
          sudo chmod 644 ${{ env.ROOT_DIRECTORY }}/docker-compose.yml

    - name: Deploy with Docker Compose
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        script_stop: true
        script: |
          cd ${{ env.ROOT_DIRECTORY }}
          COMPOSE_FILE="docker-compose.yml"
          # Authenticate Docker with GitHub Container Registry
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          # Get all services
          SERVICES=$(docker compose -f "$COMPOSE_FILE" config --services)
          # Deploy all services
          docker compose -f "$COMPOSE_FILE" pull $SERVICES
          # We skip services with container_name (e.g., db, redis) as they can't be scaled
          # Use container_name with caution as it prevents Docker from creating multiple instances
          for service in $SERVICES; do
            if ! docker compose -f "$COMPOSE_FILE" config --services "$service" | grep -q "container_name:"; then
              docker rollout -f "$COMPOSE_FILE" "$service"
            else
              echo "Skipping $service as it has a container_name specified. These are typically persistent services like db, or redis."
            fi
          done
          # Remove orphaned Docker containers
          docker container prune -f
          docker image prune -af
          echo "ðŸš€ Deployment complete! ðŸŽ‰ All services are now up and running. ðŸŒŸ"
